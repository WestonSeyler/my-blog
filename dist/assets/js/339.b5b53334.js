(window.webpackJsonp=window.webpackJsonp||[]).push([[339],{777:function(s,n,t){"use strict";t.r(n);var e=t(30),a=Object(e.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("原文地址：http://www.cnblogs.com/Unknw/p/6431375.html")]),s._v(" "),t("p",[s._v("当我们谈起React的时候，多半会将注意力集中在组件之上，思考如何将页面划分成一个个组件，以及如何编写可复用的组件。但对于接触React不久，还没有真正用它做一个完整项目的人来说，理解如何创建一个组件也并不那么简单。在最开始的时候我以为创建组件只需要调用"),t("code",[s._v("createClass")]),s._v("这个api就可以了；但学习了ES6的语法后，又知道了可以利用继承，通过"),t("code",[s._v("extends React.component")]),s._v("来创建组件；后来在阅读别人代码的时候又发现了"),t("code",[s._v("PureComponent")]),s._v("以及完全没有继承，仅仅通过返回JSX语句的方式创建组件的方式。下面这篇文章，就将逐一介绍这几种创建组件的方法，分析其特点，以及如何选择使用哪一种方式创建组件。")]),s._v(" "),t("h1",{attrs:{id:"几种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种方法"}},[s._v("#")]),s._v(" 几种方法")]),s._v(" "),t("h2",{attrs:{id:"_1-createclass"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-createclass"}},[s._v("#")]),s._v(" 1.createClass")]),s._v(" "),t("p",[s._v("如果你还没有使用ES6语法，那么定义组件，只能使用"),t("code",[s._v("React.createClass")]),s._v("这个helper来创建组件，下面是一段示例：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var React = require(\"react\");\nvar Greeting = React.createClass({\n\n  propTypes: {\n    name: React.PropTypes.string //属性校验\n  },\n\n  getDefaultProps: function() {\n    return {\n      name: 'Mary' //默认属性值\n    };\n  },\n\n  getInitialState: function() {\n    return {count: this.props.initialCount}; //初始化state\n  },\n\n  handleClick: function() {\n    //用户点击事件的处理函数\n  },\n\n  render: function() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n});\nmodule.exports = Greeting;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br")])]),t("p",[s._v("这段代码，包含了组件的几个关键组成部分，这种方式下，组件的props、state等都是以对象属性的方式组合在一起，其中默认属props和初始state都是返回对象的函数，propTypes则是个对象。这里还有一个值得注意的事情是，在createClass中，React对属性中的所有函数都进行了"),t("code",[s._v("this")]),s._v("绑定，也就是如上面的"),t("code",[s._v("hanleClick")]),s._v("其实相当于"),t("code",[s._v("handleClick.bind(this)")]),s._v(" 。")]),s._v(" "),t("h2",{attrs:{id:"_2-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-component"}},[s._v("#")]),s._v(" 2.component")]),s._v(" "),t("p",[s._v("因为ES6对类和继承有语法级别的支持，所以用ES6创建组件的方式更加优雅，下面是示例：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("import React from 'react';\nclass Greeting extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {count: props.initialCount};\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  //static defaultProps = {\n  //  name: 'Mary'  //定义defaultprops的另一种方式\n  //}\n\n  //static propTypes = {\n    //name: React.PropTypes.string\n  //}\n\n  handleClick() {\n    //点击事件的处理函数\n  }\n\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n\nGreeting.propTypes = {\n  name: React.PropTypes.string\n};\n\nGreeting.defaultProps = {\n  name: 'Mary'\n};\nexport default Greating;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br")])]),t("p",[s._v("可以看到Greeting继承自React.component,在构造函数中，通过super()来调用父类的构造函数，同时我们看到组件的state是通过在构造函数中对this.state进行赋值实现，而组件的props是在类Greeting上创建的属性，如果你对"),t("code",[s._v("类的属性")]),s._v("和"),t("code",[s._v("对象的属性")]),s._v("的区别有所了解的话，大概能理解为什么会这么做。对于组件来说，组件的props是父组件通过调用子组件向子组件传递的，子组件内部不应该对props进行修改，它更像是所有子组件实例共享的状态，不会因为子组件内部操作而改变，因此将props定义为类Greeting的属性更为合理，而在面向对象的语法中类的属性通常被称作静态(static)属性，这也是为什么props还可以像上面注释掉的方式来定义。对于Greeting类的一个实例对象的state，它是组件对象内部维持的状态，通过用户操作会修改这些状态，每个实例的state也可能不同，彼此间不互相影响，因此通过this.state来设置。")]),s._v(" "),t("p",[s._v("用这种方式创建组件时，React并没有对内部的函数进行this绑定，所以如果你想让函数在回调中保持正确的this，就要手动对需要的函数进行this绑定，如上面的handleClick，在构造函数中对this 进行了绑定。")]),s._v(" "),t("h2",{attrs:{id:"_3-purecomponet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-purecomponet"}},[s._v("#")]),s._v(" 3.PureComponet")]),s._v(" "),t("p",[s._v("我们知道，当组件的props或者state发生变化的时候：React会对组件当前的Props和State分别与nextProps和nextState进行比较，当发现变化时，就会对"),t("code",[s._v("当前组件以及子组件")]),s._v("进行重新渲染，否则就不渲染。有时候为了避免组件进行不必要的重新渲染，我们通过定义"),t("code",[s._v("shouldComponentUpdate")]),s._v("来优化性能。例如如下代码：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class CounterButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.color !== nextProps.color) {\n      return true;\n    }\n    if (this.state.count !== nextState.count) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    return (\n      <button\n        color={this.props.color}\n        onClick={() => this.setState(state => ({count: state.count + 1}))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br")])]),t("p",[t("code",[s._v("shouldComponentUpdate")]),s._v("通过判断"),t("code",[s._v("props.color")]),s._v("和"),t("code",[s._v("state.count")]),s._v("是否发生变化来决定需不需要重新渲染组件，当然有时候这种简单的判断，显得有些多余和样板化，于是React就提供了"),t("code",[s._v("PureComponent")]),s._v("来自动帮我们做这件事，这样就不需要手动来写"),t("code",[s._v("shouldComponentUpdate")]),s._v("了：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class CounterButton extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  render() {\n    return (\n      <button\n        color={this.props.color}\n        onClick={() => this.setState(state => ({count: state.count + 1}))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("p",[s._v("大多数情况下， 我们使用"),t("code",[s._v("PureComponent")]),s._v("能够简化我们的代码，并且提高性能，但是"),t("code",[s._v("PureComponent")]),s._v("的自动为我们添加的"),t("code",[s._v("shouldComponentUpate")]),s._v("函数，只是对props和state进行浅比较(shadow comparison)，当props或者state本身是嵌套对象或数组等时，浅比较并不能得到预期的结果，这会导致实际的props和state发生了变化，但组件却没有更新的问题，例如下面代码有一个"),t("code",[s._v("ListOfWords")]),s._v("组件来将单词数组拼接成逗号分隔的句子，它有一个父组件"),t("code",[s._v("WordAdder")]),s._v("让你点击按钮为单词数组添加单词，但他并不能正常工作：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class ListOfWords extends React.PureComponent {\n  render() {\n    return <div>{this.props.words.join(',')}</div>;\n  }\n }\n\nclass WordAdder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      words: ['marklar']\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // 这个地方导致了bug\n    const words = this.state.words;\n    words.push('marklar');\n    this.setState({words: words});\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick} />\n        <ListOfWords words={this.state.words} />\n      </div>\n    );\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br")])]),t("p",[s._v("这种情况下，"),t("code",[s._v("PureComponent")]),s._v("只会对this.props.words进行一次浅比较，虽然数组里面新增了元素，但是this.props.words与nextProps.words指向的仍是同一个数组，因此this.props.words !== nextProps.words 返回的便是flase，从而导致ListOfWords组件没有重新渲染,笔者之前就因为对此不太了解，而随意使用PureComponent，导致state发生变化，而视图就是不更新，调了好久找不到原因~。")]),s._v(" "),t("p",[s._v("最简单避免上述情况的方式，就是避免使用可变对象作为props和state，取而代之的是每次返回一个全新的对象,如下通过"),t("code",[s._v("concat")]),s._v("来返回新的数组：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("handleClick() {\n  this.setState(prevState => ({\n    words: prevState.words.concat(['marklar'])\n  }));\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("你可以考虑使用"),t("code",[s._v("Immutable.js")]),s._v("来创建不可变对象，通过它来简化对象比较，提高性能。\n这里还要提到的一点是虽然这里虽然使用了"),t("code",[s._v("Pure")]),s._v("这个词，但是"),t("code",[s._v("PureComponent")]),s._v("并不是纯的，因为对于纯的函数或组件应该是没有内部状态，对于"),t("code",[s._v("stateless component")]),s._v("更符合纯的定义，不了解纯函数的同学，可以参见"),t("a",{attrs:{href:"https://segmentfault.com/a/1190000007491981",target:"_blank",rel:"noopener noreferrer"}},[s._v("这篇文章"),t("OutboundLink")],1),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"_4-stateless-functional-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-stateless-functional-component"}},[s._v("#")]),s._v(" 4.Stateless Functional Component")]),s._v(" "),t("p",[s._v("上面我们提到的创建组件的方式，都是用来创建包含状态和用户交互的复杂组件，当组件本身只是用来展示，所有数据都是通过props传入的时候，我们便可以使用"),t("code",[s._v("Stateless Functional Component")]),s._v("来快速创建组件。例如下面代码所示:")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("import React from 'react';\nconst Button = ({\n  day,\n  increment\n}) => {\n  return (\n    <div>\n      <button onClick={increment}>Today is {day}</button>\n    </div>\n  )\n}\n\nButton.propTypes = {\n  day: PropTypes.string.isRequired,\n  increment: PropTypes.func.isRequired,\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("p",[s._v("这种组件，没有自身的状态，相同的props输入，必然会获得完全相同的组件展示。因为不需要关心组件的一些生命周期函数和渲染的钩子，所以不用继承自Component显得更简洁。")]),s._v(" "),t("h1",{attrs:{id:"对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[s._v("#")]),s._v(" 对比")]),s._v(" "),t("h2",{attrs:{id:"createclass-vs-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createclass-vs-component"}},[s._v("#")]),s._v(" createClass vs Component")]),s._v(" "),t("p",[s._v("对于"),t("code",[s._v("React.createClass")]),s._v(" 和 "),t("code",[s._v("extends React.Component")]),s._v("本质上都是用来创建组件，他们之间并没有绝对的好坏之分，只不过一个是ES5的语法，一个是ES6的语法支持，只不过createClass支持定义"),t("a",{attrs:{href:"https://facebook.github.io/react/docs/pure-render-mixin.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("PureRenderMixin"),t("OutboundLink")],1),s._v(",这种写法官方已经不再推荐，而是建议使用PureComponent。")]),s._v(" "),t("h2",{attrs:{id:"purecomponent-vs-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent-vs-component"}},[s._v("#")]),s._v(" pureComponent vs Component")]),s._v(" "),t("p",[s._v("通过上面对PureComponent和Component的介绍，你应该已经了解了二者的区别:"),t("code",[s._v("PureComponent")]),s._v("已经定义好了"),t("code",[s._v("shouldUpdateComponent")]),s._v("而"),t("code",[s._v("Component")]),s._v("需要显示定义。")]),s._v(" "),t("h2",{attrs:{id:"component-vs-stateless-functional-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#component-vs-stateless-functional-component"}},[s._v("#")]),s._v(" Component vs Stateless Functional component")]),s._v(" "),t("ol",[t("li",[t("p",[t("code",[s._v("Component")]),s._v("包含内部state，而"),t("code",[s._v("Stateless Functional Component")]),s._v("所有数据都来自props，没有内部state;")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Component")]),s._v(" 包含的一些生命周期函数，"),t("code",[s._v("Stateless Functional Component")]),s._v("都没有，因为"),t("code",[s._v("Stateless Functional component")]),s._v("没有"),t("code",[s._v("shouldComponentUpdate")]),s._v(",所以也无法控制组件的渲染，也即是说只要是收到新的props，"),t("code",[s._v("Stateless Functional Component")]),s._v("就会重新渲染。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Stateless Functional Component")]),s._v(" "),t("a",[s._v("不支持Refs")])])])]),s._v(" "),t("h1",{attrs:{id:"选哪个"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选哪个"}},[s._v("#")]),s._v(" 选哪个？")]),s._v(" "),t("p",[s._v("这里仅列出一些参考:")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("createClass， 除非你确实对ES6的语法一窍不通，不然的话就不要再使用这种方式定义组件。")])]),s._v(" "),t("li",[t("p",[s._v("Stateless Functional Component, 对于不需要内部状态，且用不到生命周期函数的组件，我们可以使用这种方式定义组件，比如展示性的列表组件，可以将列表项定义为Stateless Functional Component。")])]),s._v(" "),t("li",[t("p",[s._v("PureComponent/Component，对于拥有内部state，使用生命周期的函数的组件，我们可以使用二者之一，但是大部分情况下，我更推荐使用PureComponent，因为它提供了更好的性能，同时强制你使用不可变的对象，保持良好的编程习惯。")])])]),s._v(" "),t("h1",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[s._v("#")]),s._v(" 参考文章")]),s._v(" "),t("p",[t("a",{attrs:{href:"https://facebook.github.io/react/docs/optimizing-performance.html#shouldcomponentupdate-in-action",target:"_blank",rel:"noopener noreferrer"}},[s._v("optimizing-performance.html#shouldcomponentupdate-in-action"),t("OutboundLink")],1),s._v(" "),t("a",{attrs:{href:"http://www.07net01.com/2017/01/1782424.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("pureComponent介绍"),t("OutboundLink")],1),s._v(" "),t("a",{attrs:{href:"http://stackoverflow.com/questions/40703675/react-functional-stateless-component-purecomponent-component-what-are-the-dif",target:"_blank",rel:"noopener noreferrer"}},[s._v("react-functional-stateless-component-purecomponent-component-what-are-the-dif"),t("OutboundLink")],1),s._v(" "),t("a",{attrs:{href:"https://www.peterbe.com/plog/4-different-kinds-of-react-component-styles",target:"_blank",rel:"noopener noreferrer"}},[s._v("4 different kinds of React component styles"),t("OutboundLink")],1),s._v(" "),t("a",{attrs:{href:"https://facebook.github.io/react/docs/react-without-es6.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("react-without-es6"),t("OutboundLink")],1),s._v(" "),t("a",{attrs:{href:"https://toddmotto.com/react-create-class-versus-component/",target:"_blank",rel:"noopener noreferrer"}},[s._v("react-create-class-versus-component"),t("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=a.exports}}]);