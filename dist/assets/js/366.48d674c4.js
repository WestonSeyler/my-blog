(window.webpackJsonp=window.webpackJsonp||[]).push([[366],{804:function(a,s,e){"use strict";e.r(s);var r=e(30),n=Object(r.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("Observable  和 数组都有filter, map 等运算操作operators，具体的区别是什么？\n主要是两点：")]),a._v(" "),e("ol",[e("li",[a._v("延迟运算")]),a._v(" "),e("li",[a._v("渐进式取值")])]),a._v(" "),e("h2",{attrs:{id:"延迟运算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#延迟运算"}},[a._v("#")]),a._v(" 延迟运算")]),a._v(" "),e("p",[a._v("延迟运算很好理解，所有 Observable 一定会等到订阅后才开始对元素做运算，如果没有订阅就不会有运算的行为")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var source = Rx.Observable.from([1,2,3,4,5]);\nvar example = source.map(x => x + 1);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("p",[a._v("上面这段代码因为 Observable 还没有被订阅，所以不会真的对元素做运算，这跟数组的操作不一样，如下")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var source = [1,2,3,4,5];\nvar example = source.map(x => x + 1); \n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("p",[a._v("上面这段代码执行完，example 就已经取得所有元素的返回值了。")]),a._v(" "),e("p",[a._v("数组的运算都必须完整的运算出每个元素的返回值并组成一个新数组，再做下一个运算。")]),a._v(" "),e("h2",{attrs:{id:"渐进式取值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渐进式取值"}},[a._v("#")]),a._v(" 渐进式取值")]),a._v(" "),e("p",[a._v("数组的 operators 都必须完整的运算出每个元素的返回值并组成一个数组，再做下一个 operator 的运算，我们看下面这段程式码")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var source = [1,2,3];\nvar example = source\n  .filter(x => x % 2 === 0) // 这裡会运算并返回一个完整的数组\n  .map(x => x + 1) // 这裡也会运算并返回一个完整的数组\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("p",[a._v("上面这段代码，相信读者们都很熟悉了，大家应该都有注意到 "),e("code",[a._v("source.filter(...)")]),a._v("就会返回一整个新数组，再接下一个 operator 又会再返回一个新的数组，这一点其实在我们实现 map 跟 filter 时就能观察到")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Array.prototype.map = function(callback) {\n    var result = []; // 建立新数组\n    this.forEach(function(item, index, array) {\n        result.push(callback(item, index, array))\n    });\n    return result; // 返回新数组\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br")])]),e("p",[a._v("每一次的 operator 的运算都会建立一个新的数组，并在每个元素都运算完后返回这个新数组，我们可以用下面这张动态图表示运算过程")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://hexo-blog.pek3b.qingstor.com/upload_images/71414-872292e72dde44c6.gif?imageMogr2/auto-orient/strip",alt:"image.png"}})]),a._v(" "),e("p",[a._v("Observable operator 的运算方式跟数组的是完全的不同，虽然 Observable 的 operator 也都会回传一个新的 observable，但因为元素是渐进式取得的关系，所以每次的运算是一个元素运算到底，而不是运算完全部的元素再返回。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var source = Rx.Observable.from([1,2,3]);\nvar example = source\n  .filter(x => x % 2 === 0)\n  .map(x => x + 1)\n\nexample.subscribe(console.log);\n\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br")])]),e("p",[a._v("上面这段程式码运行的方式是这样的")]),a._v(" "),e("ol",[e("li",[a._v("送出 "),e("code",[a._v("1")]),a._v(" 到 filter 被过滤掉")]),a._v(" "),e("li",[a._v("送出 "),e("code",[a._v("2")]),a._v(" 到 filter 在被送到 map 转成 "),e("code",[a._v("3")]),a._v("，送到 observer "),e("code",[a._v("console.log")]),a._v(" 印出")]),a._v(" "),e("li",[a._v("送出 "),e("code",[a._v("3")]),a._v(" 到 filter 被过滤掉")])]),a._v(" "),e("p",[a._v("每个元素送出后就是运算到底，在这个过程中不会等待其他的元素运算。这就是渐进式取值的特性，不知道读者们还记不记得我们在讲 Iterator 跟 Observer 时，就特别强调这两个 Pattern 的共同特性是渐进式取值，而我们在实现 Iterator 的过程中其实就能看出这个特性的运作方式")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class IteratorFromArray {\n    constructor(arr) {\n        this._array = arr;\n        this._cursor = 0;\n    }\n\n    next() {\n        return this._cursor < this._array.length ?\n        { value: this._array[this._cursor++], done: false } :\n        { done: true };\n    }\n\n    map(callback) {\n        const iterator = new IteratorFromArray(this._array);\n        return {\n            next: () => {\n                const { done, value } = iterator.next();\n                return {\n                    done: done,\n                    value: done ? undefined : callback(value)\n                }\n            }\n        }\n    }\n}\n\nvar myIterator = new IteratorFromArray([1,2,3]);\nvar newIterator = myIterator.map(x => x + 1);\nnewIterator.next(); // { done: false, value: 2 }\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br"),e("span",{staticClass:"line-number"},[a._v("18")]),e("br"),e("span",{staticClass:"line-number"},[a._v("19")]),e("br"),e("span",{staticClass:"line-number"},[a._v("20")]),e("br"),e("span",{staticClass:"line-number"},[a._v("21")]),e("br"),e("span",{staticClass:"line-number"},[a._v("22")]),e("br"),e("span",{staticClass:"line-number"},[a._v("23")]),e("br"),e("span",{staticClass:"line-number"},[a._v("24")]),e("br"),e("span",{staticClass:"line-number"},[a._v("25")]),e("br"),e("span",{staticClass:"line-number"},[a._v("26")]),e("br"),e("span",{staticClass:"line-number"},[a._v("27")]),e("br"),e("span",{staticClass:"line-number"},[a._v("28")]),e("br"),e("span",{staticClass:"line-number"},[a._v("29")]),e("br")])]),e("p",[a._v("虽然上面这段代码是一个非常简单的示范，但可以看得出来每一次 map 虽然都会返回一个新的 Iterator，但实际上在做元素运算时，因为渐进式的特性会使一个元素运算到底，Observable 也是相同的概念，我们可以用下面这张动态图表示运算过程")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://hexo-blog.pek3b.qingstor.com/upload_images/71414-4b20a6ebaaacdc16.gif?imageMogr2/auto-orient/strip",alt:"image.png"}})]),a._v(" "),e("p",[a._v("渐进式取值的观念在 Observable 中其实非常的重要，这个特性也使得 Observable 相较于 Array 的 operator 在做运算时来的高效很多，尤其是在处理大量资料的时候会非常明显！\n(想像一下我们今天要切五万个大蛋糕，你会选择切完一个请一个人拿走，还是全部切完再拿给所有人呢？哪个会比较有效率呢？)")])])}),[],!1,null,null,null);s.default=n.exports}}]);