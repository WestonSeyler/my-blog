(window.webpackJsonp=window.webpackJsonp||[]).push([[362],{799:function(n,s,a){"use strict";a.r(s);var e=a(30),t=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("上篇说 ReactiveX.io (官网)给的定义是，Rx 是一个使用可观察数据流进行异步编程的编程接口，ReactiveX 结合了观察者模式、迭代器模式和函数式编程的精华！")]),n._v(" "),a("h2",{attrs:{id:"什么是-函数式编程-functional-programming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-函数式编程-functional-programming"}},[n._v("#")]),n._v(" 什么是 函数式编程 Functional Programming")]),n._v(" "),a("p",[n._v("简单说 Functional Programming 核心思想就是做运算处理，并用 function 来思考问题，例如像以下的算数运算式：\n例如像以下的算数运算式：\n"),a("code",[n._v("(5 + 6) - 1 * 3")])]),n._v(" "),a("p",[n._v("我们可以写成")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const add = (a, b) => a + b\nconst mul = (a, b) => a * b\nconst sub = (a, b) => a - b\n\nsub(add(5, 6), mul(1, 3))\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])]),a("p",[n._v("我们把每个运算包成一个个不同的 function，并用这些 function 组合出我们要的结果，这就是最简单的 Functional Programming。")]),n._v(" "),a("p",[n._v("函数式编程是一种编程范式，最主要的特征是，函数是第一等公民。")]),n._v(" "),a("h3",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[n._v("#")]),n._v(" 特点：")]),n._v(" "),a("ol",[a("li",[n._v("函数可以被赋值给变量\n"),a("code",[n._v("var hello = function() {}")])]),n._v(" "),a("li",[n._v("函数能被当作参数传入\n"),a("code",[n._v("fetch('www.google.com').then(function(response) {}) // 匿名 function 被传入 then()")])]),n._v(" "),a("li",[n._v("函数能被当作返回值")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var a = function(a) {\n    return function(b) {\n      return a + b;\n    }; \n    // 可以回传一个 function\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br")])]),a("ol",{attrs:{start:"4"}},[a("li",[n._v("函数式编程强调 function 要保持纯粹，只做运算并返回一个值，没有其他额外的行为。\n"),a("strong",[n._v("纯函数")]),n._v(" (Pure function 是指 一个 function 给予相同的参数，永远会回传相同的返回值，并且没有任何显著的副作用(Side Effect))")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var arr = [1, 2, 3, 4, 5];\n\narr.slice(0, 3); // [1, 2, 3]\n\narr.slice(0, 3); // [1, 2, 3]\n\narr.slice(0, 3); // [1, 2, 3]\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("这里可以看到 slice 不管执行几次，返回值都是相同的，并且除了返回一个值(value)之外并没有做任何事，所以 slice 就是一个 pure function。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var arr = [1, 2, 3, 4, 5];\n\narr.splice(0, 3); // [1, 2, 3]\n\narr.splice(0, 3); // [4, 5]\n\narr.slice(0, 3); // []\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("这里我们换成用 splice，因为 splice 每执行一次就会影响 arr 的值，导致每次结果都不同，这就很明显不是一个 pure function。")]),n._v(" "),a("h2",{attrs:{id:"函数式编程好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程好处"}},[n._v("#")]),n._v(" 函数式编程好处")]),n._v(" "),a("ul",[a("li",[n._v("可读性高")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("[9, 4]\n.concat([8, 7]) // 合并数组\n.sort()  // 排序\n.filter(x => x > 5) // 过滤出大于 5 的\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("ul",[a("li",[n._v("可维护性高\n因为纯函数等特性，执行结果不依赖外部状态，且不会对外部环境有任何操作")]),n._v(" "),a("li",[n._v("易于平行/并行处理\n因为我们基本上只做运算不碰 I/O，再加上没有 Side Effect 的特性，所以较不用担心死锁等问题。\n这节我们了解了函数式编程，下节讲下观察者模式")])])])}),[],!1,null,null,null);s.default=t.exports}}]);