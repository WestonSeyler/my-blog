(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{604:function(t,e,s){"use strict";s.r(e);var a=s(30),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"为什么使用单进程容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用单进程容器"}},[t._v("#")]),t._v(" 为什么使用单进程容器")]),t._v(" "),s("p",[t._v("使用容器时，要尽量使用单进程容器，所谓单进程容器，是指在容器运行时，只有一个工作进程。")]),t._v(" "),s("p",[t._v("如果需要存在多个进程协作的时候，要部署为两个容器，比如 PHP 一个容器，MySQL 一个容器，而不要在一个容器中运行这两者。")]),t._v(" "),s("p",[t._v("因为，Docker本身就是一个非常好的守护进程，它可以完美地管理一个进程，但是如果一个容器中存在多个进程时，你就需要自己维护两个进程的运行状态，比如使用 supervisord ，但这就大大增加了容器维护的难度和不稳定性。")]),t._v(" "),s("p",[t._v("比如在一个容器中同时运行 PHP 和 MySQL，那么如果PHP异常退出了，容器该不该连同MySQL一起退出？如果不退出，而是不断重启PHP，那么在容器之外，比如运行 docker ps 是无法了解到PHP运行状态的。")]),t._v(" "),s("p",[t._v("所以，使用docker，就要习惯于单进程容器的方式，既简单，又稳健。")]),t._v(" "),s("h2",{attrs:{id:"为什么使用无状态容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用无状态容器"}},[t._v("#")]),t._v(" 为什么使用无状态容器")]),t._v(" "),s("p",[t._v("所谓状态，是指程序在执行过程中生成的中间数据，而无状态容器，是指容器在运行时，不在容器中保存任何数据，而将数据统一保存在容器外部，比如数据库中。")]),t._v(" "),s("p",[t._v("因为有状态的容器异常重启就会造成数据丢失，也无法多副本部署，无法实现负载均衡。")]),t._v(" "),s("p",[t._v("比如PHP的Session数据默认存储在磁盘上，比如 /tmp 目录，而多副本负载均衡时，多个PHP容器的目录是彼此隔离的。比如存在两个副本A和B，用户第一次请求时候，流量被转发到A，并生成了SESSION，而第二次请求时，流量可能被负载均衡器转发到B上，而B是没有SESSION数据的，所以就会造成会话超时等BUG。")]),t._v(" "),s("p",[t._v("如果采用主机卷的方式，多个容器挂载同一个主机目录，就可以共享SESSION数据，但是如果多主机负载均衡场景，就需要将SESSION存储于外部数据库或Redis中了。")]),t._v(" "),s("p",[t._v("除了文件，还有内存数据，比如Node.js项目中使用了全局变量暂存数据，那么这个容器也是有状态的，也会出现类似BUG，所以要使用无状态容器。")]),t._v(" "),s("h2",{attrs:{id:"为什么要避免使用latest"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要避免使用latest"}},[t._v("#")]),t._v(" 为什么要避免使用latest")]),t._v(" "),s("p",[t._v("docker镜像的tag部分可以省略，默认为latest，比如：\n"),s("code",[t._v("docker pull ubuntu")])]),t._v(" "),s("p",[t._v("这当然非常方便，但是请不要这样操作。在部署镜像时或Dockerfile的FROM中，请不要省略Tag，也不要使用latest作为Tag。")]),t._v(" "),s("p",[t._v("首先，这样非常不直观，ubuntu:16.04 要比 ubuntu:latest 更加明确，使用 latest 作为标签时，我们经常需要进行思考甚至查阅仓库文档才能确定具体的版本号。")]),t._v(" "),s("p",[t._v("更重要的，latest 引用是经常变化的，随着时间的推移，此时的latest可能和下个月的latest是完全不同的版本，比如 ubuntu:latest 刚刚从 16.04 升级为 18.04，使用 latest 会给未来增加非常多的不确定性隐患，此时能部署成功，下个月也许就会出现各种问题。")]),t._v(" "),s("p",[t._v("所以，请一定避免使用latest标签，而使用稳定的、明确的、具体的版本号来标明你的依赖项。")])])}),[],!1,null,null,null);e.default=v.exports}}]);