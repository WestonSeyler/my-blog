(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{469:function(t,v,_){"use strict";_.r(v);var e=_(30),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"索引介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引介绍"}},[t._v("#")]),t._v(" 索引介绍")]),t._v(" "),_("p",[t._v("在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。\n索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据，常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树\n在InnoDB存储引擎中,主键索引是作为聚簇索引存在的，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。\n所以，"),_("strong",[t._v("哈希索引只适用于等值查询的场景")]),t._v("。")])]),t._v(" "),_("li",[_("p",[t._v("B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。")])]),t._v(" "),_("li",[_("p",[t._v("有序数组在等值查询和范围查询场景中的性能就都非常优秀。有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。")])])]),t._v(" "),_("h3",{attrs:{id:"最左前缀匹配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀匹配"}},[t._v("#")]),t._v(" 最左前缀匹配")]),t._v(" "),_("p",[t._v("根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则")]),t._v(" "),_("h3",{attrs:{id:"b-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-tree"}},[t._v("#")]),t._v(" B+ Tree")]),t._v(" "),_("p",[t._v("InnoDB的B+ Tree可能存储的是整行数据（主键索引，聚簇索引），也有可能是主键的值（非主键索引，非聚簇索引），聚簇索引查询会更快？\n因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询（过程叫回表）")]),t._v(" "),_("h3",{attrs:{id:"b-树和二叉树有什么区别和优劣"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-树和二叉树有什么区别和优劣"}},[t._v("#")]),t._v(" B+树和二叉树有什么区别和优劣?")]),t._v(" "),_("p",[t._v("B+树是多叉树，深度更小，B+树可以对叶子节点进行顺序遍历，B+树能够更好地利用磁盘扇区；二叉树：实现简单")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("哈希索引适合等值查询，做区间查询的速度很慢")]),t._v(" "),_("p",[t._v("哈希索引没办法利用索引完成排序")]),t._v(" "),_("p",[t._v("哈希索引不支持多列联合索引的最左匹配规则")]),t._v(" "),_("p",[t._v("如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题")])]),t._v(" "),_("h3",{attrs:{id:"在建立索引的时候-都有哪些需要考虑的因素呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在建立索引的时候-都有哪些需要考虑的因素呢"}},[t._v("#")]),t._v(" 在建立索引的时候,都有哪些需要考虑的因素呢?")]),t._v(" "),_("p",[t._v("定义主键的数据列一定要建立索引。")]),t._v(" "),_("p",[t._v("定义有外键的数据列一定要建立索引。")]),t._v(" "),_("p",[t._v("对于经常查询的数据列最好建立索引。")]),t._v(" "),_("p",[t._v("对于需要在指定范围内的快速或频繁查询的数据列;")]),t._v(" "),_("p",[t._v("经常用在WHERE子句中的数据列。")]),t._v(" "),_("p",[t._v("经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。")]),t._v(" "),_("p",[t._v("对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。")]),t._v(" "),_("p",[t._v("对于定义为text、image和bit的数据类型的列不要建立索引。")]),t._v(" "),_("p",[t._v("对于经常存取的列避免建立索引")]),t._v(" "),_("p",[t._v("限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。")]),t._v(" "),_("p",[t._v("对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。")]),t._v(" "),_("h3",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),_("p",[t._v("https://mp.weixin.qq.com/s/_bk2JVOm2SkXfdcvki6-0w")]),t._v(" "),_("p",[t._v("https://www.cnblogs.com/williamjie/p/11187470.html")]),t._v(" "),_("p",[t._v("https://blog.csdn.net/qq_44590469/article/details/96473238")]),t._v(" "),_("p",[t._v("https://www.sohu.com/a/331887831_120043609")])])}),[],!1,null,null,null);v.default=s.exports}}]);