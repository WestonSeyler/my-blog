(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{543:function(s,n,a){"use strict";a.r(n);var t=a(30),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("nginx-的静态文件缓存策略.md")]),s._v(" "),a("h3",{attrs:{id:"覆盖发布和非覆盖发布的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#覆盖发布和非覆盖发布的区别"}},[s._v("#")]),s._v(" 覆盖发布和非覆盖发布的区别")]),s._v(" "),a("ul",[a("li",[s._v("覆盖发布： 前端项目打包后每次产生相同的文件名，发布至服务器时，同名文件直接替换，新文件添加。")]),s._v(" "),a("li",[s._v("非覆盖式发布： 采用更新文件名的形式，比如采用webpack的[id].[chunkhash].js的形式，这样更新文件后，新文件不会影响旧文件的存在。")])]),s._v(" "),a("h3",{attrs:{id:"覆盖式发布的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#覆盖式发布的缺点"}},[s._v("#")]),s._v(" 覆盖式发布的缺点：")]),s._v(" "),a("p",[s._v("先更新页面再更新静态资源\n新页面里加载旧的资源，页面和资源对应不上，会有页面混乱，还有执行会报错。\n先更新静态资源再更新页面\n在静态资源更新完成，页面没有被更新过程中，有缓存的用户是正常的。这个时候读本地的缓存，但是如果没有缓存的用户会怎样？依然是会页面混乱和执行错误，因为在旧的页面加载新资源。")]),s._v(" "),a("p",[s._v("无论如何，覆盖式发布都是能被用户感知到的，所以部分公司的发布是晚上上线。其中如果使用vue-cli直接生成webpack配置打包的话，直接发布dist文件夹下资源就会产生这种特殊的替换问题，因为在build.js文件中存在这么一行代码，初衷应该是防止dist文件夹越来越大，但是rimraf模块会递归删除目录所有文件，没有详细了解过vue-cli生成编译环境的人，就默认的采用了这种旧资源删除新资源生成。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// build.js\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n    ...\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("接下来讲了下，我更新的发布模式。")]),s._v(" "),a("h4",{attrs:{id:"nginx的静态文件缓存策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx的静态文件缓存策略"}},[s._v("#")]),s._v(" nginx的静态文件缓存策略")]),s._v(" "),a("p",[s._v("静态资源html不使用缓存，每次加载均从服务器中拉取最新的html文件\n静态资源js/css/图片资源，采取强缓存策略，这个时间可以尽可能的长一些，因为是非覆盖式发布，所以如果html中加载资源URI更新，那么资源也会统一的更新")]),s._v(" "),a("p",[s._v("nginx可以对不同文件进行不同的缓存策略，大致配置如下（需要注意location匹配的优先级）：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('location ~ .*\\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$\n{\n    expires      7d;\n}\n\nlocation ~ .*\\.(?:js|css)$\n{\n    expires      7d;\n}\n\nlocation ~ .*\\.(?:htm|html)$\n{\n    add_header Cache-Control "private, no-store, no-cache, must-revalidate, proxy-revalidate";\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("然后发布的时候先将除html文件移动至发布路径，同名文件默认跳过，新生成的文件会产生新的hash，新旧文件不会冲突，共存在发布路径。\nhtml文件的更新当时做了两种方案")]),s._v(" "),a("ol",[a("li",[s._v("html完全由前端管理，前端发布的时候会有html文件，webpack打包时自动在html里写文件名；")]),s._v(" "),a("li",[s._v("html由后端管理（服务器渲染），前端只负责发布js、css等资源文件。在前端发布之后，后端修改版本号再发布；")])])])}),[],!1,null,null,null);n.default=e.exports}}]);